<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Live Map with Filters and Collapsible Sidebar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
    }

    #container {
      position: relative;
      height: 100%;
      width: 100%;
    }

    #map {
      height: 100%;
      width: 100%;
      position: relative;
      z-index: 1;
    }

    /* Sidebar floats above map */
    #sidePanel {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 300px;
      background-color: #0094cd;
      color: white;
      overflow-y: auto;
      padding: 1rem;
      box-sizing: border-box;
      z-index: 1000;
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      font-size: 1rem;
      line-height: 1.2;
    }

    /* When collapsed, shift sidebar left except small blue strip */
    #sidePanel.collapsed {
      transform: translateX(-280px);
      width: 300px; /* Keep width so toggle stays aligned */
      padding: 0;
    }

    /* Hide all except toggle and small blue strip when collapsed */
    #sidePanel.collapsed > *:not(#sidebarToggle) {
      display: none;
    }

    #sidebarToggle {
      position: absolute;
      top: 50%;
      left: 300px;
      transform: translateY(-50%);
      width: 32px;
      height: 32px;
      background: white;
      color: #0094cd;
      border: 2px solid #0094cd;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      transition: left 0.3s ease;
      z-index: 1100;
    }

    /* Move toggle left when sidebar collapsed */
    #sidePanel.collapsed + #sidebarToggle {
      left: 20px;
    }

    /* Filter styling */
    #filtersContainer {
      margin-bottom: 0.5rem;
    }

    #filtersContainer label {
      font-weight: bold;
      display: block;
      margin-bottom: 0.2rem;
      font-size: 1rem;
      color: white;
    }

    #filtersContainer select,
    #filtersContainer input[type="number"] {
      width: 100%;
      margin-bottom: 1rem;
      font-size: 1rem;
      box-sizing: border-box;
      padding: 0.25rem 0.4rem;
      border-radius: 4px;
      border: none;
    }

    #markerCount {
      font-weight: bold;
      margin-bottom: 1rem;
      font-size: 0.85rem;
      color: white;
    }

    #resultsHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
      margin-bottom: 0.5rem;
    }

    #downloadCsvBtn {
      background-color: #4e4e4e;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.9rem;
      white-space: nowrap;
      transition: background-color 0.3s ease;
    }

    #downloadCsvBtn:hover {
      background-color: #3a3a3a;
    }

    #nearbyList {
      flex: 1;
      font-size: 0.85rem;
      overflow-y: auto;
      color: white;
      margin-top: 0.5rem;
      overflow-wrap: break-word;
    }

    .nearby-entry {
      padding: 0.4rem 0.2rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 500;
      white-space: nowrap;
    }

    .nearby-entry:last-child {
      border-bottom: none;
    }

    .nearby-entry:hover {
      background-color: rgba(255, 255, 255, 0.15);
    }

    .distance {
      font-weight: normal;
      font-size: 0.75rem;
      opacity: 0.8;
      min-width: 50px;
      text-align: right;
      font-style: normal;
    }

    /* Glowing effect on marker icon */
    .glowing-marker {
      filter: drop-shadow(0 0 5px #00caff) drop-shadow(0 0 10px #00caff);
      z-index: 1000 !important;
      transition: filter 0.3s ease;
    }

    /* Leaflet zoom control positioned relative to sidebar toggle */
    .leaflet-control-zoom {
      position: absolute !important;
      top: 10px !important;
      left: 310px !important;
      transition: left 0.3s ease;
      z-index: 1200 !important;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidePanel">
      <div id="filtersContainer">
        <label for="typeFilter">Filter by Type:</label>
        <select id="typeFilter">
          <option value="">All Types</option>
        </select>

        <label for="distanceFilter">Distance (km):</label>
        <input type="number" id="distanceFilter" min="1" max="1000" step="1" value="50" />
      </div>

      <div id="markerCount">No marker selected</div>

      <div id="resultsHeader">
        <h3 style="margin: 0;">Results</h3>
        <button id="downloadCsvBtn">Download Results</button>
      </div>

      <div id="nearbyList">Click a marker to see nearby entries.</div>
    </div>

    <div id="sidebarToggle">&#x276E;</div>

    <div id="map"></div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const sheetURL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vSm2djr9eOyF8SI92KcfrCsrFEcW3dmaStUT4H0Ard8A1BUKKgd08owmHvG6TT7AdfPXB26pJ-Stzjw/pub?gid=528897676&single=true&output=csv";

    // Initialize map without default zoom control
    const map = L.map("map", { zoomControl: false }).setView([50.5, -95.0], 4);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    // Add zoom control manually to control position
    const zoomControl = L.control.zoom({ position: "topleft" }).addTo(map);

    function updateZoomControlPosition(isCollapsed) {
      const zoomEl = document.querySelector(".leaflet-control-zoom");
      if (!zoomEl) return;
      zoomEl.style.left = isCollapsed ? "30px" : "310px";
    }

    updateZoomControlPosition(false);

    let markers = [];
    let allData = [];
    let selectedMarker = null;
    let radiusCircle = null;

    const sidePanel = document.getElementById("sidePanel");
    const sidebarToggle = document.getElementById("sidebarToggle");
    const nearbyList = document.getElementById("nearbyList");
    const markerCount = document.getElementById("markerCount");
    const typeFilterSelect = document.getElementById("typeFilter");
    const distanceInput = document.getElementById("distanceFilter");
    const downloadBtn = document.getElementById("downloadCsvBtn");

    // Icons for markers
    const defaultIcon = new L.Icon.Default();

    const blueIcon = new L.Icon({
      iconUrl:
        "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png",
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41],
    });

    const yellowIcon = new L.Icon({
      iconUrl:
        "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-yellow.png",
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41],
    });

    const greyIcon = new L.Icon({
      iconUrl:
        "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png",
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41],
    });

    // Load CSV data
    fetch(sheetURL)
      .then((res) => res.text())
      .then((csv) => {
        const parsed = Papa.parse(csv, { header: true, skipEmptyLines: true });
        allData = parsed.data;

        // Populate type filter options dynamically
        const typeSet = new Set();
        allData.forEach((row) => {
          if (row["Geocode"] && row["Geocode"].includes(",")) {
            typeSet.add(row["Type"]);
          }
        });

        Array.from(typeSet)
          .sort()
          .forEach((type) => {
            const opt = document.createElement("option");
            opt.value = type;
            opt.textContent = type;
            typeFilterSelect.appendChild(opt);
          });

        updateMap();

        typeFilterSelect.addEventListener("change", updateMap);
        distanceInput.addEventListener("input", updateMap);
        downloadBtn.addEventListener("click", downloadResults);
      });

    function updateMap() {
      // Remove old markers and circle
      markers.forEach((m) => map.removeLayer(m));
      markers = [];

      if (radiusCircle) {
        map.removeLayer(radiusCircle);
        radiusCircle = null;
      }

      selectedMarker = null;
      updateMarkerCount(0);

      const typeFilter = typeFilterSelect.value;
      allData.forEach((row) => {
        if (typeFilter && row["Type"] !== typeFilter) return;

        const geocode = row["Geocode"];
        if (!geocode || !geocode.includes(",")) return;

        const [lat, lng] = geocode.split(",").map(Number);
        if (isNaN(lat) || isNaN(lng)) return;

        const marker = L.marker([lat, lng], { icon: greyIcon });
        marker.data = row;

        marker.on("click", function () {
          // Reset icons
          markers.forEach((m) => m.setIcon(greyIcon));

          if (radiusCircle) {
            map.removeLayer(radiusCircle);
            radiusCircle = null;
          }

          selectedMarker = marker;

          let radiusKm = parseFloat(distanceInput.value);
          if (isNaN(radiusKm) || radiusKm <= 0) radiusKm = 50;

          const selectedLatLng = marker.getLatLng();

          // Find nearby markers within radius
          let nearby = findNearbyMarkers(marker, radiusKm);

          // Calculate distances & sort ascending
          nearby = nearby
            .map((m) => ({
              marker: m,
              distance: haversineDistance(selectedLatLng, m.getLatLng()),
            }))
            .sort((a, b) => a.distance - b.distance);

          // Update icons
          nearby.forEach((entry) => entry.marker.setIcon(blueIcon));
          marker.setIcon(yellowIcon);

          // Draw radius circle
          radiusCircle = L.circle(marker.getLatLng(), {
            radius: radiusKm * 1000,
            color: "#999",
            fillColor: "#ccc",
            fillOpacity: 0.15,
            weight: 1,
          }).addTo(map);

          // Update nearby list
          updateNearbyList(marker, nearby, radiusKm);

          updateMarkerCount(nearby.length);

          // Popup
          const popupHTML = `
            <strong>${marker.data["First Name"]} ${marker.data["Last Name"]}</strong><br>
            ${marker.data["Business Name"]}<br>
            <em>${marker.data["Membership"]}</em><br><br>
            <strong>${nearby.length} nearby markers within ${radiusKm} km</strong>
          `;
          marker.bindPopup(popupHTML).openPopup();
        });

        marker.addTo(map);
        markers.push(marker);
      });
    }

    function updateNearbyList(selectedMarker, nearby, radiusKm) {
      nearbyList.innerHTML = "";

      // Selected marker at top
      const d = selectedMarker.data;
      const divSelected = document.createElement("div");
      divSelected.className = "nearby-entry";
      divSelected.innerHTML = `
            <div class="name-distance" style="display:flex; justify-content: space-between; width: 100%; font-weight:bold;">
              <span>${d["First Name"]} ${d["Last Name"]} (Selected)</span>
              <span class="distance">0.0 km</span>
            </div>
            <div>${d["Business Name"]}</div>
            <em>${d["Membership"]}</em>
          `;
      nearbyList.appendChild(divSelected);

      if (nearby.length === 0) {
        const noDiv = document.createElement("div");
        noDiv.textContent = "No nearby markers found.";
        nearbyList.appendChild(noDiv);
      } else {
        nearby.forEach(({ marker, distance }) => {
          const d = marker.data;
          const distanceFixed = distance.toFixed(1);
          const div = document.createElement("div");
          div.className = "nearby-entry";
          div.innerHTML = `
              <div class="name-distance" style="display:flex; justify-content: space-between; width: 100%;">
                <span>${d["First Name"]} ${d["Last Name"]}</span>
                <span class="distance">${distanceFixed} km</span>
              </div>
              <div>${d["Business Name"]}</div>
              <em>${d["Membership"]}</em>
            `;
          nearbyList.appendChild(div);

          // Glow on hover on sidebar list entry
          div.addEventListener("mouseenter", () => {
            if (marker._icon) marker._icon.classList.add("glowing-marker");
          });
          div.addEventListener("mouseleave", () => {
            if (marker._icon) marker._icon.classList.remove("glowing-marker");
          });
        });
      }
    }

    function updateMarkerCount(count) {
      if (count === 0) {
        markerCount.textContent = "No marker selected";
      } else {
        markerCount.textContent = `Total nearby markers: ${count}`;
      }
    }

    function findNearbyMarkers(clickedMarker, radiusKm) {
      const nearby = [];
      const clickedLatLng = clickedMarker.getLatLng();

      markers.forEach((marker) => {
        if (marker === clickedMarker) return;
        const dist = haversineDistance(clickedLatLng, marker.getLatLng());
        if (dist <= radiusKm) {
          nearby.push(marker);
        }
      });

      return nearby;
    }

    function haversineDistance(latlng1, latlng2) {
      const R = 6371;
      const dLat = ((latlng2.lat - latlng1.lat) * Math.PI) / 180;
      const dLon = ((latlng2.lng - latlng1.lng) * Math.PI) / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((latlng1.lat * Math.PI) / 180) *
          Math.cos((latlng2.lat * Math.PI) / 180) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function downloadResults() {
      if (markers.length === 0) {
        alert("No results to download.");
        return;
      }

      const typeFilter = typeFilterSelect.value;

      // Filter markers currently on map by type (matches updateMap filter)
      const filteredMarkers = markers.filter((marker) => {
        if (typeFilter && marker.data["Type"] !== typeFilter) return false;
        return true;
      });

      if (filteredMarkers.length === 0) {
        alert("No results to download.");
        return;
      }

      // Extract all keys from filtered markers to keep CSV structure
      const allKeysSet = new Set();
      filteredMarkers.forEach((marker) => {
        Object.keys(marker.data).forEach((k) => allKeysSet.add(k));
      });
      const allKeys = Array.from(allKeysSet);

      // Build CSV rows
      const rows = [allKeys.join(",")];
      filteredMarkers.forEach((marker) => {
        const row = allKeys
          .map((key) => {
            const val = marker.data[key];
            if (val === undefined) return "";
            // Escape quotes and commas
            if (typeof val === "string" && (val.includes(",") || val.includes('"'))) {
              return `"${val.replace(/"/g, '""')}"`;
            }
            return val;
          })
          .join(",");
        rows.push(row);
      });

      const csvString = rows.join("\n");
      const blob = new Blob([csvString], { type: "text/csv" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "map_results.csv";
      a.click();

      URL.revokeObjectURL(url);
    }

    // Sidebar toggle logic
    sidebarToggle.addEventListener("click", () => {
      const isCollapsed = sidePanel.classList.toggle("collapsed");
      sidebarToggle.innerHTML = isCollapsed ? "&#x276F;" : "&#x276E;"; // ❯ or ❮
      updateZoomControlPosition(isCollapsed);
    });
  </script>
</body>
</html>
